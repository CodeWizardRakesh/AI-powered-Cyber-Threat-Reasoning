


pfp
I'm going to build a system for cyber treat reasoning using language model. 




That sounds like an ambitious and fascinating project! Building a system for cyber threat reasoning using a language model could have significant applications in cybersecurity, helping to identify, analyze, and respond to threats more effectively. I’d be happy to assist you in brainstorming, designing, or refining this idea. Let’s start by breaking it down—what are your goals for this system, and what specific capabilities do you want it to have? For example:

Do you want it to detect threats by analyzing text (e.g., logs, reports, or social media)?
Should it reason about potential attack vectors or predict threat likelihood?
Are you aiming for it to generate actionable insights or recommendations?
Feel free to share as much or as little as you’d like, and I’ll tailor my suggestions to your vision!







just tell me how do I build it using google technologies like gemini api, vertex ai and other data souce api's for gathering informations




20 web pages
Building a cyber threat reasoning system using Google technologies like the Gemini API, Vertex AI, and other data source APIs is a powerful approach to leverage AI for cybersecurity. Below, I’ll outline a step-by-step process to design and implement such a system. This will focus on using Google’s tools for reasoning, data integration, and threat analysis.

Step 1: Define the System’s Purpose and Requirements
Goal: Create a system that analyzes cyber threat data, reasons about potential risks, and provides actionable insights.
Capabilities:
Collect data from multiple sources (e.g., threat intelligence feeds, logs, APIs).
Use the Gemini API (via Vertex AI) for natural language reasoning and threat analysis.
Integrate external data source APIs (e.g., VirusTotal, NIST NVD, or X posts) for real-time threat information.
Generate human-readable reports or alerts.
Tools:
Gemini API on Vertex AI: For reasoning and generating insights from unstructured text.
Vertex AI: To host and manage the model, tools, and deployment.
Google Cloud Functions or Cloud Run: For serverless API calls and processing.
BigQuery: For storing and querying structured threat data.
External APIs: To gather real-time cyber threat intelligence.
Step 2: Set Up Your Google Cloud Environment
Create a Google Cloud Project:
Go to the Google Cloud Console, create a new project (e.g., "CyberThreatReasoning").
Note your project ID (e.g., cyber-threat-reasoning-123).
Enable Required APIs:
Enable the Vertex AI API (aiplatform.googleapis.com).
Enable the Cloud Functions API (cloudfunctions.googleapis.com) or Cloud Run API (run.googleapis.com) for processing.
Enable the BigQuery API (bigquery.googleapis.com) for data storage.
Set Up Authentication:
Install the Google Cloud SDK (gcloud) locally.
Run gcloud auth application-default login to authenticate with your credentials.
Assign the Vertex AI User role (roles/aiplatform.user) to your account or service account.
Step 3: Design the System Architecture
Here’s a high-level architecture:

Data Ingestion Layer: Collect threat data from APIs (e.g., VirusTotal, NIST NVD) and store it in BigQuery.
Processing Layer: Use Cloud Functions or Cloud Run to preprocess data and call the Gemini API via Vertex AI.
Reasoning Layer: Leverage Gemini on Vertex AI to analyze and reason about threats.
Output Layer: Generate insights, reports, or alerts (e.g., via email, Slack, or a dashboard).
Step 4: Gather Data Using External APIs
You’ll need to integrate external data sources to feed your system with threat intelligence. Here’s an example using Python and the VirusTotal API:

Install Dependencies:
bash

Collapse

Wrap

Copy
pip install google-cloud-vertexai google-cloud-bigquery requests
Sample Code to Fetch Threat Data:
python

Collapse

Wrap

Copy
import requests
from google.cloud import bigquery

# VirusTotal API key (get from virustotal.com)
VT_API_KEY = "your-virus-total-api-key"
url = "https://www.virustotal.com/api/v3/domains/google.com"

headers = {"x-apikey": VT_API_KEY}
response = requests.get(url, headers=headers)
threat_data = response.json()

# Store in BigQuery
client = bigquery.Client(project="cyber-threat-reasoning-123")
table_id = "cyber-threat-reasoning-123.threat_dataset.vt_threats"
rows_to_insert = [threat_data]
errors = client.insert_rows_json(table_id, rows_to_insert)
if not errors:
    print("Threat data stored in BigQuery!")
Replace "google.com" with a domain or IP you want to analyze.
Add more APIs (e.g., NIST NVD: https://nvd.nist.gov/developers) as needed.
Step 5: Set Up Vertex AI and Gemini API
Initialize Vertex AI:
Use the Vertex AI SDK to interact with the Gemini model.
Define the Reasoning Logic:
Use Gemini to analyze threat data and reason about potential risks.
Sample Code:
python

Collapse

Wrap

Copy
from google.cloud import vertexai
from google.cloud.vertexai.preview import reasoning_engines

# Initialize Vertex AI
vertexai.init(project="cyber-threat-reasoning-123", location="us-central1")

# Define the model (e.g., Gemini 1.5 Pro)
model = "gemini-1.5-pro"

# Define a reasoning function
def analyze_threat(threat_data):
    prompt = f"""
    Analyze the following cyber threat data and provide a risk assessment:
    {threat_data}
    Include potential attack vectors and mitigation steps.
    """
    response = reasoning_engines.RemoteModel(model).query(prompt)
    return response.text

# Example usage
threat_data = {"domain": "example.com", "malware_detected": True, "source": "VirusTotal"}
result = analyze_threat(threat_data)
print(result)
The Gemini model will process the unstructured threat data and return a reasoned response.
Step 6: Add Tools for Enhanced Reasoning
Vertex AI supports tools (e.g., function calling) to fetch real-time data or perform actions. For example, you can add a tool to query external APIs dynamically.

Define a Tool:
python

Collapse

Wrap

Copy
def fetch_latest_threats(domain):
    url = f"https://www.virustotal.com/api/v3/domains/{domain}"
    headers = {"x-apikey": VT_API_KEY}
    response = requests.get(url, headers=headers)
    return response.json()

tools = [
    {
        "name": "fetch_latest_threats",
        "description": "Fetches the latest threat data for a domain from VirusTotal.",
        "parameters": {"domain": "string"}
    }
]
Integrate with Reasoning Engine:
Deploy the reasoning engine with tools:
python

Collapse

Wrap

Copy
reasoning_engine = reasoning_engines.ReasoningEngine.create(
    model=model,
    tools=tools,
    requirements=["requests"]
)
The model can now call fetch_latest_threats during reasoning if needed.
Step 7: Deploy the System
Deploy on Vertex AI:
Use the Vertex AI Reasoning Engine to deploy your model and tools as a managed service:
python

Collapse

Wrap

Copy
deployed_engine = reasoning_engine.deploy()
print(f"Deployed at: {deployed_engine.endpoint}")
Test Locally First:
Before deploying, test locally with sample data:
python

Collapse

Wrap

Copy
response = reasoning_engine.query("Analyze threats for example.com")
print(response)
Step 8: Process and Output Results
Store Results: Save insights back to BigQuery or send them to a dashboard (e.g., Google Data Studio).
Alerts: Use Cloud Functions to send alerts via email or Slack:
python

Collapse

Wrap

Copy
from google.cloud import functions_v1

def send_alert(context, data):
    # Logic to send email or Slack message
    print(f"Alert: {data}")
Step 9: Scale and Monitor
Scale: Use Cloud Run for high-throughput processing or BigQuery for large datasets.
Monitor: Set up Google Cloud Monitoring to track API usage and performance.
Example Workflow
Fetch threat data from VirusTotal and store it in BigQuery.
Use Gemini on Vertex AI to analyze the data and reason about risks.
Generate a report: "High-risk domain detected: example.com. Potential attack vector: Malware. Mitigation: Block domain and scan endpoints."
Send an alert via Cloud Functions.
Additional Tips
Security: Use IAM roles and VPC Service Controls to secure your deployment.
Cost: Monitor API usage (Gemini, Vertex AI, and external APIs) to manage costs.
Extensibility: Add more APIs (e.g., Shodan, ThreatCrowd) or integrate X posts for real-time sentiment analysis.
This setup leverages Google’s AI and cloud infrastructure to build a robust cyber threat reasoning system. Let me know if you’d like to dive deeper into any part!







cools.. now you make the AI generated report part to display like an LLM applications generates the texts like word by word it generates. But dont change anything from previous please


app.py:
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)

        # Convert timestamp to datetime format
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")

        # Remove duplicates & missing values
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)

        return df
    except Exception as e:
        return f"Error loading data: {e}"

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None

    # Count number of events per IP
    event_counts = df["Source IP"].value_counts().head(5).to_dict()

    # Filter high-severity events
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]

    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return None

    log_text = df.head(5).to_string(index=False)

    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """

    response = model.generate_content(prompt)
    return response.text

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)

            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            threat_report = generate_threat_report(df)

            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   threat_report=threat_report)
    return render_template("index.html")

if __name__ == "__main__":
    app.run(debug=True)

script.js:

document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    commandInput.addEventListener("keypress", function(event) {
        if (event.key === "Enter") {
            let command = commandInput.value.trim();
            if (command) {
                outputDiv.innerHTML += <p>> ${command}</p>;
                processCommand(command);
            }
            commandInput.value = "";
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }
    });

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += <p>${response}</p>;
    }
});


index.html:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <pre>{{ threat_report }}</pre>
        </div>
        {% endif %}
    </div>
</body>
</html>

style.css:

@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}



2 / 2



To make the AI-generated report display word-by-word like an LLM application, we'll modify the Flask app to stream the report generation and update the front-end (HTML and JavaScript) to render it dynamically. We'll use Flask's streaming capabilities and JavaScript to simulate the word-by-word effect without altering the previous logic you provided.

Here’s how we’ll adapt your code:

Updated app.py
We’ll modify the generate_threat_report function to stream the response from the Gemini API and create a new route to handle the streaming.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)

        # Convert timestamp to datetime format
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")

        # Remove duplicates & missing values
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)

        return df
    except Exception as e:
        return f"Error loading data: {e}"

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None

    # Count number of events per IP
    event_counts = df["Source IP"].value_counts().head(5).to_dict()

    # Filter high-severity events
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]

    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return None

    log_text = df.head(5).to_string(index=False)

    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """

    response = model.generate_content(prompt)
    return response.text

# Stream the report generation word-by-word
def stream_threat_report(df):
    """Streams the threat report word-by-word."""
    report = generate_threat_report(df)
    if not report:
        yield "Error generating report."
        return

    # Split the report into words
    words = report.split()
    for word in words:
        yield f"{word} "
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)

            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)

            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], request.args.get("filename"))
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/plain")

if __name__ == "__main__":
    app.run(debug=True)
Updated index.html
We’ll modify the HTML to include a <div> for the streaming report and trigger the streaming via JavaScript after the file is uploaded.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output"></div>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
We’ll add logic to fetch the streaming report and display it word-by-word in the threat-report div.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report after form submission
    const form = document.getElementById("upload-form");
    const reportDiv = document.getElementById("threat-report");

    if (form && reportDiv) {
        form.addEventListener("submit", function(event) {
            const fileInput = form.querySelector("input[type='file']");
            const filename = fileInput.files[0].name;

            // After form submission, fetch the streaming report
            setTimeout(() => {
                const eventSource = new EventSource(`/stream-report?filename=${filename}`);
                reportDiv.innerHTML = ""; // Clear previous content

                eventSource.onmessage = function(event) {
                    reportDiv.innerHTML += event.data; // Append each word
                    reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
                };

                eventSource.onerror = function() {
                    reportDiv.innerHTML += "\n[Report generation complete]";
                    eventSource.close();
                };
            }, 1000); // Delay to ensure file is uploaded
        });
    }
});
Updated style.css
Add styling for the streaming report output to match the aesthetic.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}
How It Works
Backend: The stream_threat_report function splits the report into words and yields them one-by-one with a slight delay (time.sleep(0.1)), mimicking LLM generation. The /stream-report route streams this data.
Frontend: After form submission, JavaScript uses EventSource to listen for streamed data from the /stream-report endpoint and appends each word to the threat-report div.
Display: The report appears word-by-word in the styled report-output div, maintaining the cyberpunk aesthetic.
Running the App
Ensure you have the required dependencies (flask, pandas, google-generativeai).
Set your GOOGLE_API_KEY in the environment:
bash

Collapse

Wrap

Copy
export GOOGLE_API_KEY="your-api-key"
Run the app:
bash

Collapse

Wrap

Copy
python app.py
Upload a CSV file with threat logs (e.g., columns: Timestamp, Source IP, Severity), and watch the report generate word-by-word.
This keeps your previous logic intact while adding the streaming effect you requested! Let me know if you need tweaks or sample CSV data to test it.







hey no words are displaying in AI generated report part please help




If no words are displaying in the AI-generated report section, there could be a few issues at play—either with the streaming mechanism, the front-end rendering, or the data being processed. Let’s troubleshoot and fix this step-by-step without changing the core logic from your previous setup.

Potential Issues and Fixes
1. Streaming Route Not Triggering Correctly
The /stream-report route relies on the filename being passed correctly from the form submission. If the filename isn’t reaching the server or the file isn’t found, the report won’t generate.

Fix: Update the JavaScript to ensure the filename is correctly passed and add error handling in the backend.

2. EventSource Not Receiving Data
The EventSource in script.js might not be interpreting the streamed data correctly due to MIME type issues or improper event formatting.

Fix: Ensure the streamed response uses the correct text/event-stream MIME type and format.

3. Data Preprocessing or Report Generation Failing
If load_and_preprocess_data or generate_threat_report returns None or encounters an error, no data will be streamed.

Fix: Add debugging logs to check the data flow.

4. Frontend Rendering Issue
The threat-report div might not be updating because the EventSource isn’t appending data correctly.

Fix: Simplify the streaming to use fetch with ReadableStream for better control and debugging.

Updated Code with Fixes
app.py
Add error handling and ensure streaming works with proper event-stream formatting.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report generation word-by-word
def stream_threat_report(df):
    """Streams the threat report word-by-word."""
    report = generate_threat_report(df)
    if not report:
        yield "data: Error generating report.\n\n"
        return
    words = report.split()
    for word in words:
        yield f"data: {word} \n\n"  # SSE format
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)  # Pass filename to template
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html
Pass the filename to JavaScript and ensure the report div is present.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output"></div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
script.js
Switch to EventSource with proper SSE handling and add debugging.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename); // Debug
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        reportDiv.innerHTML = ""; // Clear previous content

        eventSource.onmessage = function(event) {
            console.log("Received data:", event.data); // Debug
            reportDiv.innerHTML += event.data + " "; // Append word with space
            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred"); // Debug
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});
style.css (Unchanged)
The styling is fine as is.

Debugging Steps
Check Console Logs:
Open your browser’s developer tools (F12) and look at the Console tab. You should see:
"Streaming report for filename: <filename>"
"Received data: <word>" for each word streamed.
If you don’t see these, the issue is with the EventSource connection or filename.
Verify File Upload:
Ensure the uploaded CSV file is saved in the uploads/ folder and is accessible.
Check that the CSV has the expected columns (Timestamp, Source IP, Severity).
Test the Stream:
Visit http://127.0.0.1:5000/stream-report?filename=<your-uploaded-filename> directly in the browser. You should see words streaming in the data: <word> format.
Gemini API Response:
If the report is empty, ensure your GOOGLE_API_KEY is valid and the Gemini API is responding. Add print(response.text) in generate_threat_report to debug.
Sample CSV to Test
Create a file named test_logs.csv:

text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
Upload this file to test the app.

Expected Behavior
Upload the CSV.
See "Top Threat Sources" and "High-Risk Events" displayed.
The "AI-Generated Cyber Threat Report" section should populate word-by-word (e.g., {"Summary": "High-risk activity detected", ...}).
If it still doesn’t work, let me know what you see in the console logs or any errors, and I’ll refine the fix!







cools.....it works now can you change the code to make the content to be displayed in structured form not as it as json form




Awesome, glad it’s working now! To display the AI-generated report in a structured, human-readable format instead of raw JSON, we’ll need to:

Parse the JSON response from the Gemini API in the backend.
Stream the structured content (e.g., sections like "Summary," "Threat Patterns," "Recommended Actions") word-by-word.
Update the frontend to render it nicely with HTML formatting instead of plain text.
I’ll modify the code to achieve this without altering the core functionality you’ve built so far.

Updated app.py
We’ll parse the JSON and structure the report into sections, streaming each part word-by-word.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import json

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report in a structured format
def stream_threat_report(df):
    """Streams the threat report in structured form word-by-word."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    try:
        # Parse JSON response
        report_data = json.loads(report)
        summary = report_data.get("Summary", "No summary provided.")
        patterns = report_data.get("Threat Patterns", "No patterns identified.")
        actions = report_data.get("Recommended Actions", "No actions recommended.")

        # Structure the report
        structured_report = (
            "Summary:\n" + summary + "\n\n" +
            "Threat Patterns:\n" + patterns + "\n\n" +
            "Recommended Actions:\n" + actions
        )
    except json.JSONDecodeError:
        # Fallback if JSON parsing fails
        structured_report = "Raw Report:\n" + report

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word} \n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
Updated index.html
Add specific divs for each section of the report to structure the display.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
Modify the JavaScript to append words to the correct section based on the structured report.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = "summary"; // Start with summary
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            console.log("Received data:", event.data);
            const word = event.data.trim();

            // Switch sections based on keywords
            if (word === "Summary:") {
                currentSection = "summary";
                return; // Skip the label itself
            } else if (word === "Threat") {
                currentSection = "patterns";
                return; // Skip "Threat" (next word is "Patterns:")
            } else if (word === "Patterns:") {
                return; // Skip "Patterns:"
            } else if (word === "Recommended") {
                currentSection = "actions";
                return; // Skip "Recommended" (next word is "Actions:")
            } else if (word === "Actions:") {
                return; // Skip "Actions:"
            }

            // Append word to the correct section
            if (currentSection === "summary") {
                summaryDiv.innerHTML += ` ${word}`;
            } else if (currentSection === "patterns") {
                patternsDiv.innerHTML += ` ${word}`;
            } else if (currentSection === "actions") {
                actionsDiv.innerHTML += ` ${word}`;
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "<p>[Report generation complete]</p>";
            eventSource.close();
        };
    }
});
Updated style.css
Add styling for the structured sections.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}
How It Works
Backend:
The stream_threat_report function parses the JSON response into a structured string with sections ("Summary," "Threat Patterns," "Recommended Actions").
It streams each word with the data: prefix for Server-Sent Events (SSE).
Frontend:
The JavaScript detects section headers ("Summary:", "Threat Patterns:", "Recommended Actions:") and switches the currentSection variable to append words to the correct div (summary, patterns, actions).
Each section is styled with a bold label and populated word-by-word.
Display:
Instead of raw JSON (e.g., {"Summary": "High-risk activity", ...}), you’ll see:
text

Collapse

Wrap

Copy
Summary: High-risk activity detected from 192.168.1.10
Threat Patterns: Potential brute-force attempts
Recommended Actions: Block IP and notify team
Testing
Use the same test_logs.csv from before:

text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
Upload it, and the report should now appear in a structured format, building up word-by-word.
If you run into any issues or want further refinements (e.g., bullet points, different styling), just let me know!







hey it works but the contents are not displaying please help




If the structured sections ("Summary," "Threat Patterns," "Recommended Actions") are appearing but the actual content (e.g., the text after "Summary:") isn’t displaying, the issue likely lies in how the JavaScript is handling the streamed words or how the backend is formatting the report. Let’s troubleshoot and fix this step-by-step.

Possible Issues
JavaScript Section Switching Logic: The eventSource.onmessage logic might be skipping content words due to overly strict conditions for switching sections.
Backend Streaming Format: The streamed data might not be parsed correctly, or the JSON response from Gemini might not be structured as expected.
Debugging Visibility: We need to see what’s being streamed to confirm the data flow.
Updated Code with Fixes
app.py
Add debugging prints and ensure the structured report is streamed correctly.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import json

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response: {response.text}")  # Debug
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report in a structured format
def stream_threat_report(df):
    """Streams the threat report in structured form word-by-word."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    try:
        # Parse JSON response
        report_data = json.loads(report)
        summary = report_data.get("Summary", "No summary provided.")
        patterns = report_data.get("Threat Patterns", "No patterns identified.")
        actions = report_data.get("Recommended Actions", "No actions recommended.")

        # Structure the report
        structured_report = (
            "Summary: " + summary + "\n" +
            "Threat Patterns: " + patterns + "\n" +
            "Recommended Actions: " + actions
        )
        print(f"Structured report: {structured_report}")  # Debug
    except json.JSONDecodeError:
        print("JSON parsing failed, using raw report")  # Debug
        structured_report = "Raw Report: " + report

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html (Unchanged)
The HTML structure is fine as is, with separate divs for each section.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
script.js
Simplify and fix the section-switching logic to ensure content is appended correctly.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = "summary"; // Start with summary
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received word:", word); // Debug

            // Switch sections based on keywords
            if (word === "Summary:") {
                currentSection = "summary";
            } else if (word === "Threat") {
                // Wait for "Patterns:" to switch
            } else if (word === "Patterns:") {
                currentSection = "patterns";
            } else if (word === "Recommended") {
                // Wait for "Actions:" to switch
            } else if (word === "Actions:") {
                currentSection = "actions";
            } else {
                // Append content to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "<p>[Report generation complete]</p>";
            eventSource.close();
        };
    }
});
style.css (Unchanged)
The styling is still good.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}
Debugging Steps
Check Server Logs:
Run the app (python app.py) and upload your CSV.
Look for:
Raw Gemini response: <json_string> (e.g., {"Summary": "High-risk activity", ...})
Structured report: Summary: High-risk activity\nThreat Patterns: ...
If these don’t appear or show errors, the issue is with the Gemini API or JSON parsing.
Check Browser Console:
Open developer tools (F12) and watch the Console tab.
You should see:
Streaming report for filename: test_logs.csv
Received word: Summary:, Received word: High-risk, etc.
If words stop after section headers (e.g., "Summary:"), the JavaScript logic was too restrictive—fixed now.
Test with Sample CSV: Use:
text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
Expected output:
Summary: "High-risk activity from 192.168.1.10" (word-by-word)
Threat Patterns: "Potential brute-force attempts"
Recommended Actions: "Block IP and notify team"
Key Changes
Backend: Added debug prints to verify the raw and structured report. Simplified the structured report by removing extra newlines for cleaner streaming.
JavaScript: Fixed the section-switching logic to only change currentSection on full header words (e.g., "Summary:", "Patterns:") and append all other words to the current section.
Expected Result
After uploading the CSV:

"Summary:" appears, followed by its content (e.g., "High-risk activity from 192.168.1.10") word-by-word.
"Threat Patterns:" appears, followed by its content.
"Recommended Actions:" appears, followed by its content.
If the content still doesn’t show, please share:

The server logs (from app.py).
The browser console output. I’ll pinpoint the exact issue from there!






still no conent generated. It displayed:

summary:

Threat Pattern:

Recommended Actions:

but no contents




If the section headers ("Summary:", "Threat Patterns:", "Recommended Actions:") are displaying but no content follows, the issue is likely either:

The Gemini API isn’t returning the expected JSON content.
The JSON parsing in stream_threat_report isn’t extracting the content correctly.
The JavaScript isn’t appending the content words due to a logic error.
Let’s add more debugging and fix the flow to ensure the content displays.

Updated app.py
We’ll add detailed logging to see the raw response and structured report, and ensure the content is streamed properly.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import json

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response: {response.text}")  # Debug raw output
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report in a structured format
def stream_threat_report(df):
    """Streams the threat report in structured form word-by-word."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    try:
        # Parse JSON response
        report_data = json.loads(report)
        summary = str(report_data.get("Summary", "No summary provided."))
        patterns = str(report_data.get("Threat Patterns", "No patterns identified."))
        actions = str(report_data.get("Recommended Actions", "No actions recommended."))

        # Structure the report with clear delimiters
        structured_report = (
            "Summary: " + summary + " || " +
            "Threat Patterns: " + patterns + " || " +
            "Recommended Actions: " + actions
        )
        print(f"Structured report: {structured_report}")  # Debug structured output
    except json.JSONDecodeError as e:
        print(f"JSON parsing failed: {e}, using raw report")
        structured_report = "Raw Report: " + report

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html (Unchanged)
The structure is still good.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
script.js
Update the logic to handle the new delimiter ("||") and ensure content is appended correctly.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = "summary"; // Start with summary
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received word:", word); // Debug

            // Switch sections based on keywords or delimiter
            if (word === "Summary:") {
                currentSection = "summary";
            } else if (word === "Threat") {
                // Wait for "Patterns:" to switch
            } else if (word === "Patterns:") {
                currentSection = "patterns";
            } else if (word === "Recommended") {
                // Wait for "Actions:" to switch
            } else if (word === "Actions:") {
                currentSection = "actions";
            } else if (word === "||") {
                // Delimiter to switch sections
                if (currentSection === "summary") {
                    currentSection = "patterns";
                } else if (currentSection === "patterns") {
                    currentSection = "actions";
                }
            } else {
                // Append content to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "<p>[Report generation complete]</p>";
            eventSource.close();
        };
    }
});
style.css (Unchanged)
The styling is still appropriate.

Debugging Steps
Server Logs:
Run python app.py and upload your CSV.
Check the terminal for:
Raw Gemini response: {"Summary": "High-risk activity...", ...}
Structured report: Summary: High-risk activity... || Threat Patterns: ... || Recommended Actions: ...
If the raw response is empty or not JSON, the issue is with the Gemini API call. Ensure your API key is valid and the prompt is clear.
Browser Console:
Open developer tools (F12) and watch the Console tab.
You should see:
Received word: Summary:
Received word: High-risk
Received word: || (switching sections)
Received word: Threat
Received word: Patterns:
And so on...
If you only see the headers and no content words, the JSON might not have the expected fields.
Test with Sample CSV: Use:
text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
Key Changes
Backend:
Added a || delimiter between sections to make section switching explicit in the stream.
Converted JSON values to strings explicitly with str() to avoid type errors.
More detailed debug prints to trace the data.
JavaScript:
Updated the section-switching logic to use the || delimiter for transitions between sections.
Ensured all non-header/non-delimiter words are appended to the current section.
Expected Output
After uploading the CSV, you should see:

Summary: "High-risk activity from 192.168.1.10" (word-by-word)
Threat Patterns: "Potential brute-force attempts"
Recommended Actions: "Block IP and notify team"
If it still shows only headers:

Share the server logs (e.g., Raw Gemini response and Structured report lines).
Share the browser console output (e.g., Received word: lines). I’ll pinpoint exactly where the content is getting lost!






still no resposes i think there is not problem with the gemini api.Okay let's now diplay only the summary



2 / 2



If there’s no content displaying despite the Gemini API likely working, it suggests the issue might be in how the streamed data is being processed or rendered. Since you’re confident the Gemini API isn’t the problem, let’s simplify the approach: we’ll focus on displaying only the "Summary" section to isolate the issue and ensure it works. We’ll streamline the backend to extract just the summary and update the frontend accordingly.

Updated app.py
Extract only the "Summary" from the Gemini response and stream it.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import json

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response: {response.text}")  # Debug raw output
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream only the summary
def stream_threat_report(df):
    """Streams only the summary from the threat report word-by-word."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    try:
        # Parse JSON response and extract only the Summary
        report_data = json.loads(report)
        summary = str(report_data.get("Summary", "No summary provided."))
        structured_report = "Summary: " + summary
        print(f"Structured summary: {structured_report}")  # Debug structured output
    except json.JSONDecodeError as e:
        print(f"JSON parsing failed: {e}, using raw report")
        structured_report = "Raw Report: " + report

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
Updated index.html
Simplify to show only the "Summary" section.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
            </div>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
Simplify to handle only the summary section.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        const summaryDiv = document.getElementById("summary");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received word:", word); // Debug

            // Append every word after "Summary:" to the summary div
            if (word !== "Summary:") {
                summaryDiv.innerHTML += ` ${word}`;
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "<p>[Report generation complete]</p>";
            eventSource.close();
        };
    }
});
style.css (Unchanged)
The styling remains suitable.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}
Debugging Steps
Server Logs:
Run python app.py and upload your CSV.
Check for:
Raw Gemini response: {"Summary": "High-risk activity...", ...}
Structured summary: Summary: High-risk activity...
If the raw response lacks a "Summary" field or isn’t valid JSON, we’ll need to adjust the prompt or handle the response differently.
Browser Console:
Open developer tools (F12) and check the Console tab.
You should see:
Received word: Summary:
Received word: High-risk
Received word: activity
etc.
If you only see Received word: Summary: and nothing else, the summary content isn’t being streamed.
Test with Sample CSV: Use:
text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
Expected Output
After uploading the CSV, the "Summary:" header appears, followed by the content (e.g., "High-risk activity from 192.168.1.10") displayed word-by-word.
If It Still Doesn’t Work
If "Summary:" shows up but no content follows:

Share the server logs (e.g., Raw Gemini response and Structured summary lines).
Share the browser console output (e.g., Received word: lines). This will help me see exactly what the Gemini API is returning and where the content is getting lost.
Once we get the summary working, we can easily expand it back to include the other sections if you’d like!







import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report generation word-by-word
def stream_threat_report(df):
    """Streams the threat report word-by-word."""
    report = generate_threat_report(df)
    if not report:
        yield "data: Error generating report.\n\n"
        return
    words = report.split()
    for word in words:
        yield f"data: {word} \n\n"  # SSE format
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)  # Pass filename to template
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)



style.css:

@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}


script.js:

document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename); // Debug
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        reportDiv.innerHTML = ""; // Clear previous content

        eventSource.onmessage = function(event) {
            console.log("Received data:", event.data); // Debug
            reportDiv.innerHTML += event.data + " "; // Append word with space
            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred"); // Debug
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});	


index.html:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output"></div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>




hey this works great now i want you to display the summary, threat patten and recommoneded actions in separare div.




Great to hear it’s working well now! To display "Summary," "Threat Patterns," and "Recommended Actions" in separate <div> elements, we’ll need to:

Parse the Gemini response in the backend to extract these fields.
Stream the report with clear delimiters for each section.
Update the frontend (HTML and JavaScript) to render each section in its own <div>.
Here’s how we’ll modify your code:

Updated app.py
Parse the response and stream each section separately with delimiters.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import json

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond in JSON format with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response: {response.text}")  # Debug
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report:
        yield "data: Error generating report.\n\n"
        return

    try:
        # Parse JSON response
        report_data = json.loads(report)
        summary = str(report_data.get("Summary", "No summary provided."))
        patterns = str(report_data.get("Threat Patterns", "No patterns identified."))
        actions = str(report_data.get("Recommended Actions", "No actions recommended."))

        # Structure the report with delimiters
        structured_report = (
            "SUMMARY_START " + summary + " SUMMARY_END " +
            "PATTERNS_START " + patterns + " PATTERNS_END " +
            "ACTIONS_START " + actions + " ACTIONS_END"
        )
        print(f"Structured report: {structured_report}")  # Debug
    except json.JSONDecodeError as e:
        print(f"JSON parsing failed: {e}")
        structured_report = "Error: Invalid report format."

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
Updated index.html
Add separate <div> elements for each section.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
Parse the delimiters and append words to the correct <div>.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = null;
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received data:", word); // Debug

            // Switch sections based on delimiters
            if (word === "SUMMARY_START") {
                currentSection = "summary";
            } else if (word === "SUMMARY_END") {
                currentSection = null;
            } else if (word === "PATTERNS_START") {
                currentSection = "patterns";
            } else if (word === "PATTERNS_END") {
                currentSection = null;
            } else if (word === "ACTIONS_START") {
                currentSection = "actions";
            } else if (word === "ACTIONS_END") {
                currentSection = null;
            } else if (currentSection) {
                // Append word to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});
Updated style.css
Add styling for the separate sections (minor tweak to your existing CSS).

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container






Interrupted
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report generation word-by-word
def stream_threat_report(df):
    """Streams the threat report word-by-word."""
    report = generate_threat_report(df)
    if not report:
        yield "data: Error generating report.\n\n"
        return
    words = report.split()
    for word in words:
        yield f"data: {word} \n\n"  # SSE format
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)  # Pass filename to template
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)



style.css:

@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}


script.js:

document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename); // Debug
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        reportDiv.innerHTML = ""; // Clear previous content

        eventSource.onmessage = function(event) {
            console.log("Received data:", event.data); // Debug
            reportDiv.innerHTML += event.data + " "; // Append word with space
            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred"); // Debug
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});	


index.html:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output"></div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>




hey this works great now i want you to display the summary, threat patten and recommoneded actions in separare div.




Since your current setup works great, I’ll modify it to display "Summary," "Threat Patterns," and "Recommended Actions" in separate <div> elements. The Gemini response isn’t in JSON format (it’s plain text with fields as per your prompt), so we’ll need to parse it manually in the backend and stream it with delimiters for the frontend to separate into distinct sections.

Here’s the updated code:

Updated app.py
Parse the plain text response and stream it with section delimiters.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields: "Summary", "Threat Patterns", "Recommended Actions".
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response: {response.text}")  # Debug
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response (assuming it’s formatted as "Summary: ... Threat Patterns: ... Recommended Actions: ...")
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."
    
    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if line.startswith("Summary:"):
            current_section = "summary"
            summary = line[len("Summary:"):].strip()
        elif line.startswith("Threat Patterns:"):
            current_section = "patterns"
            patterns = line[len("Threat Patterns:"):].strip()
        elif line.startswith("Recommended Actions:"):
            current_section = "actions"
            actions = line[len("Recommended Actions:"):].strip()
        elif current_section and line:
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")  # Debug

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
Updated index.html
Add separate <div> elements for "Summary," "Threat Patterns," and "Recommended Actions."

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
Handle the delimiters and append words to the appropriate <div>.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = null;
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received data:", word); // Debug

            // Switch sections based on delimiters
            if (word === "SUMMARY_START") {
                currentSection = "summary";
            } else if (word === "SUMMARY_END") {
                currentSection = null;
            } else if (word === "PATTERNS_START") {
                currentSection = "patterns";
            } else if (word === "PATTERNS_END") {
                currentSection = null;
            } else if (word === "ACTIONS_START") {
                currentSection = "actions";
            } else if (word === "ACTIONS_END") {
                currentSection = null;
            } else if (currentSection) {
                // Append word to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});
Updated style.css
Add styling for the separate sections (minor tweak to your existing CSS).

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}
How It Works
Backend (app.py):
The generate_threat_report function requests a plain text response with fields "Summary," "Threat Patterns," and "Recommended Actions."
stream_threat_report parses the response by splitting it into lines and assigning content to each section based on the field headers.
It streams the report with delimiters (SUMMARY_START, PATTERNS_START, ACTIONS_START) to mark the beginning and end of each section.
Frontend (index.html and script.js):
The HTML includes three <div> elements with IDs summary, patterns, and actions.
The JavaScript uses EventSource to listen for streamed words, switching the currentSection based on delimiters and appending content to the appropriate <div>.
Styling (style.css):
Each section is styled with a bold label and separated with a small margin.
Expected Output
After uploading a CSV like:

text

Collapse

Wrap

Copy
Timestamp,Source IP,Severity
2025-03-21 10:00:00,192.168.1.10,High
2025-03-21 10:01:00,192.168.1.10,Critical
2025-03-21 10:02:00,10.0.0.5,Low
The report should display:

Summary: "High-risk activity detected from 192.168.1.10" (word-by-word)
Threat Patterns: "Potential brute-force attempts"
Recommended Actions: "Block IP and notify security team"
Each section will appear in its own <div> under the "AI-Generated Cyber Threat Report" header.

Debugging
If it doesn’t work as expected:

Server Logs: Check the terminal for Raw Gemini response and Structured report. Ensure the response includes the fields and they’re parsed correctly.
Browser Console: Look at Received data: logs. You should see SUMMARY_START, followed by summary words, then SUMMARY_END, and so on.
Let me know what you see, and I’ll refine it further!
This should give you the separate sections you wanted while keeping the word-by-word streaming effect. Let me know how it goes!







🛡 AI-Powered Cyber Threat Reasoning
Cyber_logs.csv Analyze Threats
🔹 Top Threat Sources:
{'192.168.1.10': 1, '192.168.1.15': 1, '203.0.113.5': 1}
🔹 High-Risk Events:
[{'Timestamp': Timestamp('2025-03-21 10:30:00+0000', tz='UTC'), 'Source IP': '192.168.1.10', 'Destination IP': '8.8.8.8', 'Event Type': 'Unauthorized Access', 'Severity': 'High', 'Description': 'Multiple failed login attempts detected.'}, {'Timestamp': Timestamp('2025-03-21 10:35:00+0000', tz='UTC'), 'Source IP': '192.168.1.15', 'Destination IP': '10.0.0.5', 'Event Type': 'Malware Detected', 'Severity': 'Critical', 'Description': 'Malicious file detected in system folder.'}]
🔹 AI-Generated Cyber Threat Report:

                
Summary: No summary provided.

                
Threat Patterns: No patterns identified.

                
Recommended Actions: No actions recommended.

            
[Report generation complete]




It looks like the app is running, but the "AI-Generated Cyber Threat Report" is showing default fallback messages ("No summary provided," etc.) instead of actual content from the Gemini API. This suggests the parsing in stream_threat_report isn’t correctly extracting the "Summary," "Threat Patterns," and "Recommended Actions" from the Gemini response. The issue could be:

The Gemini response format doesn’t match what the parsing logic expects (e.g., it’s not prefixed with "Summary:", "Threat Patterns:", etc.).
The response might be empty or malformed.
Let’s debug and fix this by:

Adding more robust parsing to handle the Gemini response.
Ensuring the streamed content reflects what Gemini returns.
Here’s the updated code based on your output:

Updated app.py
Improve parsing and add debugging to see the raw response.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields clearly labeled as:
    "Summary: <your summary>"
    "Threat Patterns: <your patterns>"
    "Recommended Actions: <your actions>"
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response:\n{response.text}")  # Debug raw output
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."
    
    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if line.startswith("Summary:"):
            current_section = "summary"
            summary = line[len("Summary:"):].strip()
        elif line.startswith("Threat Patterns:"):
            current_section = "patterns"
            patterns = line[len("Threat Patterns:"):].strip()
        elif line.startswith("Recommended Actions:"):
            current_section = "actions"
            actions = line[len("Recommended Actions:"):].strip()
        elif current_section and line:
            # Append additional lines to the current section
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")  # Debug structured output

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html (Unchanged)
Your current index.html already has the correct structure with separate <div> elements.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
script.js (Unchanged)
Your current script.js correctly handles the delimiters.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = null;
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received data:", word); // Debug

            // Switch sections based on delimiters
            if (word === "SUMMARY_START") {
                currentSection = "summary";
            } else if (word === "SUMMARY_END") {
                currentSection = null;
            } else if (word === "PATTERNS_START") {
                currentSection = "patterns";
            } else if (word === "PATTERNS_END") {
                currentSection = null;
            } else if (word === "ACTIONS_START") {
                currentSection = "actions";
            } else if (word === "ACTIONS_END") {
                currentSection = null;
            } else if (currentSection) {
                // Append word to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});
style.css (Unchanged)
Your current styling is fine.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}
Changes Made
Prompt Adjustment:
Updated the prompt in generate_threat_report to explicitly request fields labeled as "Summary:", "Threat Patterns:", and "Recommended Actions:" to match the parsing logic.
Debugging:
Added print statements to log the raw Gemini response and the structured report for troubleshooting.
Parsing Logic:
The stream_threat_report function splits the response into lines and looks for the field labels to assign content. It also handles multi-line responses by appending additional lines to the current section.
Debugging Steps
Run the App:
Use your Cyber_logs.csv:
text

Collapse

Wrap

Copy
Timestamp,Source IP,Destination IP,Event Type,Severity,Description
2025-03-21 10:30:00,192.168.1.10,8.8.8.8,Unauthorized Access,High,Multiple failed login attempts detected.
2025-03-21 10:35:00,192.168.1.15,10.0.0.5,Malware Detected,Critical,Malicious file detected in system folder.
2025-03-21 10:40:00,203.0.113.5,192.168.1.1,Port Scan,Low,Scanning multiple ports.
Upload it and watch the terminal.
Check Server Logs:
Look for:
Raw Gemini response: (should show something like "Summary: High-risk activity... Threat Patterns: ... Recommended Actions: ...")
Structured report: (should show the delimited version, e.g., SUMMARY_START High-risk ... SUMMARY_END PATTERNS_START ...)
If the raw response is empty or doesn’t match the expected format, the issue is with Gemini’s output.
Check Browser Console:
Open developer tools (F12) and look at Received data: logs.
You should see SUMMARY_START, followed by summary words, then SUMMARY_END, etc.
Expected Output
Based on your CSV, it should now display something like:

Summary: "High-risk activity detected from 192.168.1.10 and 192.168.1.15."
Threat Patterns: "Unauthorized access attempts and malware presence."
Recommended Actions: "Block IPs 192.168.1.10 and 192.168.1.15, scan systems for malware."
Each section should populate word-by-word in its own <div>.

If It Still Shows Defaults
If you still see "No summary provided," etc.:

Share the server logs (specifically Raw Gemini response and Structured report).
I’ll adjust the parsing to match whatever format Gemini is returning.
Let me know how it goes or if you need further tweaks!







🛡 AI-Powered Cyber Threat Reasoning
No file chosen Analyze Threats
🔹 Top Threat Sources:
{'192.168.1.10': 1, '192.168.1.15': 1, '203.0.113.5': 1}
🔹 High-Risk Events:
[{'Timestamp': Timestamp('2025-03-21 10:30:00+0000', tz='UTC'), 'Source IP': '192.168.1.10', 'Destination IP': '8.8.8.8', 'Event Type': 'Unauthorized Access', 'Severity': 'High', 'Description': 'Multiple failed login attempts detected.'}, {'Timestamp': Timestamp('2025-03-21 10:35:00+0000', tz='UTC'), 'Source IP': '192.168.1.15', 'Destination IP': '10.0.0.5', 'Event Type': 'Malware Detected', 'Severity': 'Critical', 'Description': 'Malicious file detected in system folder.'}]
🔹 AI-Generated Cyber Threat Report:

                
Summary: No summary provided.

                
Threat Patterns: No patterns identified.

                
Recommended Actions: No actions recommended.

            
[Report generation complete]

why




The output you’re seeing—where "Top Threat Sources" and "High-Risk Events" are populated, but the "AI-Generated Cyber Threat Report" shows "No summary provided," "No patterns identified," and "No actions recommended"—indicates that the Gemini API response isn’t being parsed correctly by the stream_threat_report function. The default fallback values are being used because the parsing logic isn’t finding the expected "Summary:", "Threat Patterns:", and "Recommended Actions:" fields in the response.

Here’s why this might be happening and how we’ll fix it:

Possible Causes
Gemini Response Format Mismatch:
The prompt asks for fields labeled "Summary:", "Threat Patterns:", and "Recommended Actions:", but Gemini might not be returning the response in this exact format (e.g., it could be JSON, plain text without labels, or something else).
Your earlier working version expected a different format, and the current parsing assumes a specific structure.
Empty or Invalid Response:
The Gemini API might be returning an empty string, an error, or a response that doesn’t match the expected structure.
Parsing Logic Issue:
The current parsing logic relies on startswith() to detect section headers, but if the response lacks these headers or uses different wording, it fails to extract content.
Debugging Plan
Add more detailed logging to see the exact Gemini response.
Make the parsing more flexible to handle variations in the response format.
Test with your CSV to ensure the content is extracted and streamed.
Updated app.py
Add robust parsing and debugging.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import re

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields clearly labeled as:
    "Summary: <your summary>"
    "Threat Patterns: <your patterns>"
    "Recommended Actions: <your actions>"
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response:\n{repr(response.text)}")  # Debug with repr() for exact string
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."

    # Split into lines and use regex for flexible parsing
    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if re.match(r"Summary:.*", line, re.IGNORECASE):
            current_section = "summary"
            summary = line[len("Summary:"):].strip()
        elif re.match(r"Threat Patterns:.*", line, re.IGNORECASE):
            current_section = "patterns"
            patterns = line[len("Threat Patterns:"):].strip()
        elif re.match(r"Recommended Actions:.*", line, re.IGNORECASE):
            current_section = "actions"
            actions = line[len("Recommended Actions:"):].strip()
        elif current_section and line:
            # Append additional lines to the current section
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    # If no content was found, log the issue
    if summary == "No summary provided." and patterns == "No patterns identified." and actions == "No actions recommended.":
        print("Warning: No content parsed from Gemini response.")

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")  # Debug structured output

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html, script.js, and style.css (Unchanged)
Your current versions of these files are correct and don’t need changes:

index.html already has separate <div> elements for "summary," "patterns," and "actions."
script.js correctly handles the SUMMARY_START, PATTERNS_START, and ACTIONS_START delimiters.
style.css provides the necessary styling.
Changes Made
Prompt Clarity:
Ensured the prompt explicitly requests fields with "Summary:", "Threat Patterns:", and "Recommended Actions:" labels.
Flexible Parsing:
Used re.match with re.IGNORECASE to make the parsing case-insensitive and more robust (e.g., handles "summary:" or "SUMMARY:").
Added a warning log if no content is parsed, to confirm the issue is with the response.
Debugging:
Used repr(response.text) to show the exact string (including newlines, quotes, etc.) from Gemini.
Added a warning if the parsing falls back to defaults.
Debugging Steps
Run with Your CSV:
Use your Cyber_logs.csv:
text

Collapse

Wrap

Copy
Timestamp,Source IP,Destination IP,Event Type,Severity,Description
2025-03-21 10:30:00,192.168.1.10,8.8.8.8,Unauthorized Access,High,Multiple failed login attempts detected.
2025-03-21 10:35:00,192.168.1.15,10.0.0.5,Malware Detected,Critical,Malicious file detected in system folder.
2025-03-21 10:40:00,203.0.113.5,192.168.1.1,Port Scan,Low,Scanning multiple ports.
Upload it and watch the terminal.
Check Server Logs:
Look for:
Raw Gemini response: (e.g., "Summary: High-risk activity detected...\nThreat Patterns: ...\nRecommended Actions: ...")
Structured report: (e.g., SUMMARY_START High-risk ... SUMMARY_END PATTERNS_START ...)
Warning: No content parsed from Gemini response. (if present, the response doesn’t match the expected format).
Share these logs with me if the defaults still appear.
Browser Console:
Check Received data: logs in the browser (F12).
You should see SUMMARY_START, followed by summary words, then SUMMARY_END, etc.
Expected Output
After uploading Cyber_logs.csv, you should see:

Summary: "High-risk activity detected from 192.168.1.10 and 192.168.1.15."
Threat Patterns: "Unauthorized access attempts and malware presence."
Recommended Actions: "Block IPs 192.168.1.10 and 192.168.1.15, scan systems for malware."
Each section should populate word-by-word in its own <div>.

Why It’s Showing Defaults Now
The most likely reason is that the Gemini response isn’t formatted as expected. For example:

If it returns JSON (e.g., {"Summary": "..."}), the current parsing won’t find "Summary:" and will use defaults.
If it returns plain text without labels (e.g., "High-risk activity..."), the parsing fails.
If it’s empty or an error, the defaults kick in.
The logs will reveal the exact response. Please share:

The Raw Gemini response: line from the terminal.
The Structured report: line (if present). I’ll tailor the parsing to match what Gemini is actually returning!






this is output in terminal:


the compromise.\n"
Warning: No content parsed from Gemini response.
Structured report: SUMMARY_START No summary provided. SUMMARY_END PATTERNS_START No patterns identified. PATTERNS_END ACTIONS_START No actions recommended. ACTIONS_END
127.0.0.1 - - [21/Mar/2025 22:26:02] "GET /stream-report?filename=Cyber_logs.csv HTTP/1.1" 200 -
127.0.0.1 - - [21/Mar/2025 22:26:06] "POST / HTTP/1.1" 200 -
127.0.0.1 - - [21/Mar/2025 22:26:06] "GET /static/css/style.css HTTP/1.1" 304 -
127.0.0.1 - - [21/Mar/2025 22:26:06] "GET /static/js/script.js HTTP/1.1" 304 -
Raw Gemini response:
'**Summary:**\n\nThe logs reveal three significant cybersecurity incidents.  First, a system at 192.168.1.10 experienced multiple failed login attempts, suggesting a brute-force attack. Second, malware was discovered on a system at 192.168.1.15.  Third, a system at 10.1.1.7 was subjected to a port scan from an external IP address (203.0.113.5).\n\n\n**Threat Patterns:**\n\n* **Brute-Force Attack:**  Multiple failed login attempts from 192.168.1.10 to 8.8.8.8 (likely a DNS server) indicate an attempt to guess login credentials.\n\n* **Malware Infection:** The detection of a malicious file on 192.168.1.15 suggests a successful compromise, possibly through phishing, a drive-by download, or exploiting a vulnerability.\n\n* **Port Scanning:** The multiple connection attempts from 203.0.113.5 to 10.1.1.7 suggest reconnaissance activity, likely aimed at identifying open ports for potential exploitation.\n\n\n**Recommended Actions:**\n\n1. **Block IP Addresses:** Temporarily block the IP address 203.0.113.5 from accessing the internal network to prevent further port scanning attempts.  Investigate the source of this IP address.  Consider adding it to a firewall blacklist.\n\n2. **Strengthen Password Policies:** Implement stronger password policies on all systems, including password complexity requirements, minimum length, and enforced regular changes.  Consider multi-factor authentication (MFA).\n\n3. **Malware Remediation:** Immediately isolate the compromised system at 192.168.1.15 from the network to prevent further spread of malware.  Perform a full malware scan and removal using appropriate antivirus and anti-malware tools.  Consider restoring the system from a known-good backup if available.\n\n4. **Intrusion Detection/Prevention System (IDS/IPS):** Review and enhance the IDS/IPS rules to detect and block brute-force attacks and port scanning activities more effectively.  Tune existing rules based on the detected patterns.\n\n5. **Vulnerability Management:** Conduct a thorough vulnerability assessment and penetration testing to identify and address any security weaknesses that might have been exploited.  Patch all known vulnerabilities promptly.\n\n6. **Security Awareness Training:** Provide security awareness training to users to educate them about phishing attempts, safe browsing practices, and the importance of strong passwords.\n\n7. **Notify Security Team:**  Escalate these incidents to the security team for further investigation and incident response.  Detailed investigation is needed to determine the root cause of each incident and take appropriate actions to prevent future occurrences.  Collect relevant forensic data from affected systems.\n\n8. **Log Analysis and Monitoring:** Enhance log monitoring capabilities to proactively detect similar threats in the future.  Implement centralized log management and analysis to gain better visibility into security events.\n'
Warning: No content parsed from Gemini response.
Structured report: SUMMARY_START No summary provided. SUMMARY_END PATTERNS_START No patterns identified. PATTERNS_END ACTIONS_START No actions recommended. ACTIONS_END
127.0.0.1 - - [21/Mar/2025 22:26:11] "GET /stream-report?filename=Cyber_logs.csv HTTP/1.1" 200 -



This one in UI:
🛡 AI-Powered Cyber Threat Reasoning
No file chosen Analyze Threats
🔹 Top Threat Sources:
{'192.168.1.10': 1, '192.168.1.15': 1, '203.0.113.5': 1}
🔹 High-Risk Events:
[{'Timestamp': Timestamp('2025-03-21 10:30:00+0000', tz='UTC'), 'Source IP': '192.168.1.10', 'Destination IP': '8.8.8.8', 'Event Type': 'Unauthorized Access', 'Severity': 'High', 'Description': 'Multiple failed login attempts detected.'}, {'Timestamp': Timestamp('2025-03-21 10:35:00+0000', tz='UTC'), 'Source IP': '192.168.1.15', 'Destination IP': '10.0.0.5', 'Event Type': 'Malware Detected', 'Severity': 'Critical', 'Description': 'Malicious file detected in system folder.'}]
🔹 AI-Generated Cyber Threat Report:

                
Summary: No summary provided.

                
Threat Patterns: No patterns identified.

                
Recommended Actions: No actions recommended.

            
[Report generation complete]




Thanks for sharing the logs! The issue is clear now: the Gemini API is returning a response with Markdown-style headers (**Summary:**, **Threat Patterns:**, **Recommended Actions:**) instead of the plain text labels (Summary:, Threat Patterns:, Recommended Actions:) that the parsing logic expects. That’s why it’s falling back to the defaults ("No summary provided," etc.).

The re.match in the current code is looking for exact matches to "Summary:", but the response uses **Summary:**, so it’s not being detected. Let’s update the parsing logic to handle this Markdown format and extract the content correctly.

Updated app.py
Adjust the parsing to recognize **Summary:**, **Threat Patterns:**, and **Recommended Actions:**.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import re

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields clearly labeled as:
    "**Summary:** <your summary>"
    "**Threat Patterns:** <your patterns>"
    "**Recommended Actions:** <your actions>"
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response:\n{repr(response.text)}")  # Debug with repr()
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response with Markdown headers
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."

    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if re.match(r"\*\*Summary:\*\*.*", line, re.IGNORECASE):
            current_section = "summary"
            summary = line[len("**Summary:**"):].strip()
        elif re.match(r"\*\*Threat Patterns:\*\*.*", line, re.IGNORECASE):
            current_section = "patterns"
            patterns = line[len("**Threat Patterns:**"):].strip()
        elif re.match(r"\*\*Recommended Actions:\*\*.*", line, re.IGNORECASE):
            current_section = "actions"
            actions = line[len("**Recommended Actions:**"):].strip()
        elif current_section and line:
            # Append additional lines to the current section
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    # If no content was found, log the issue
    if summary == "No summary provided." and patterns == "No patterns identified." and actions == "No actions recommended.":
        print("Warning: No content parsed from Gemini response.")

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")  # Debug structured output

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)
index.html, script.js, and style.css (Unchanged)
Your existing versions are correct:

index.html has the <div> elements for "summary," "patterns," and "actions."
script.js handles the SUMMARY_START, PATTERNS_START, and ACTIONS_START delimiters.
style.css styles the sections appropriately.
Changes Made
Prompt Alignment:
Updated the prompt to explicitly request **Summary:**, **Threat Patterns:**, and **Recommended Actions:** to match the response format Gemini is using.
Parsing Fix:
Modified the re.match patterns to look for **Summary:**, **Threat Patterns:**, and **Recommended Actions:** (with escaped asterisks \*\* in the regex).
Kept the logic to append multi-line content to each section.
Debugging:
The repr() in the debug output ensures we see the exact string, including newlines and special characters.
Expected Output in Terminal
After uploading Cyber_logs.csv, you should see something like:

text

Collapse

Wrap

Copy
Raw Gemini response:
'**Summary:**\n\nThe logs reveal three significant cybersecurity incidents...\n\n**Threat Patterns:**\n\n* **Brute-Force Attack:** Multiple failed login attempts...\n\n**Recommended Actions:**\n\n1. **Block IP Addresses:** Temporarily block...'
Structured report: SUMMARY_START The logs reveal three significant cybersecurity incidents... SUMMARY_END PATTERNS_START * Brute-Force Attack: Multiple failed login attempts... PATTERNS_END ACTIONS_START 1. Block IP Addresses: Temporarily block... ACTIONS_END
Expected Output in UI
Based on your CSV:

Summary: "The logs reveal three significant cybersecurity incidents. First, a system at 192.168.1.10 experienced multiple failed login attempts, suggesting a brute-force attack. Second, malware was discovered on a system at 192.168.1.15. Third, a system at 10.1.1.7 was subjected to a port scan from an external IP address (203.0.113.5)."
Threat Patterns: "* Brute-Force Attack: Multiple failed login attempts from 192.168.1.10 to 8.8.8.8 (likely a DNS server) indicate an attempt to guess login credentials. * Malware Infection: The detection of a malicious file on 192.168.1.15 suggests a successful compromise, possibly through phishing, a drive-by download, or exploiting a vulnerability. * Port Scanning: The multiple connection attempts from 203.0.113.5 to 10.1.1.7 suggest reconnaissance activity, likely aimed at identifying open ports for potential exploitation."
Recommended Actions: "1. Block IP Addresses: Temporarily block the IP address 203.0.113.5 from accessing the internal network to prevent further port scanning attempts. Investigate the source of this IP address. Consider adding it to a firewall blacklist. 2. Strengthen Password Policies: Implement stronger password policies on all systems, including password complexity requirements, minimum length, and enforced regular changes. Consider multi-factor authentication (MFA). 3. Malware Remediation: Immediately isolate the compromised system at 192.168.1.15 from the network to prevent further spread of malware. Perform a full malware scan and removal using appropriate antivirus and anti-malware tools. Consider restoring the system from a known-good backup if available. ..."
Each section should appear word-by-word in its own <div>.

Debugging
If it still shows defaults:

Check Terminal Logs:
Confirm the Raw Gemini response matches the Markdown format with **Summary:**, etc.
If it’s different (e.g., JSON or plain text without headers), share the exact output, and I’ll adjust the parsing.
Browser Console:
Look at Received data: logs (F12). You should see SUMMARY_START, followed by content words, not just the defaults.
This should resolve the issue based on the response format you provided. Let me know how it works or if you see something unexpected!







app.py:
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response
import time
import re

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields clearly labeled as:
    "**Summary:** <your summary>"
    "**Threat Patterns:** <your patterns>"
    "**Recommended Actions:** <your actions>"
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response:\n{repr(response.text)}")  # Debug with repr()
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Stream the report with sections separated by delimiters
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response with Markdown headers
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."

    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if re.match(r"\*\*Summary:\*\*.*", line, re.IGNORECASE):
            current_section = "summary"
            summary = line[len("**Summary:**"):].strip()
        elif re.match(r"\*\*Threat Patterns:\*\*.*", line, re.IGNORECASE):
            current_section = "patterns"
            patterns = line[len("**Threat Patterns:**"):].strip()
        elif re.match(r"\*\*Recommended Actions:\*\*.*", line, re.IGNORECASE):
            current_section = "actions"
            actions = line[len("**Recommended Actions:**"):].strip()
        elif current_section and line:
            # Append additional lines to the current section
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    # If no content was found, log the issue
    if summary == "No summary provided." and patterns == "No patterns identified." and actions == "No actions recommended.":
        print("Warning: No content parsed from Gemini response.")

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")  # Debug structured output

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)  # Simulate word-by-word generation

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

if __name__ == "__main__":
    app.run(debug=True)

index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>

script.js:
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = null;
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received data:", word); // Debug

            // Switch sections based on delimiters
            if (word === "SUMMARY_START") {
                currentSection = "summary";
            } else if (word === "SUMMARY_END") {
                currentSection = null;
            } else if (word === "PATTERNS_START") {
                currentSection = "patterns";
            } else if (word === "PATTERNS_END") {
                currentSection = null;
            } else if (word === "ACTIONS_START") {
                currentSection = "actions";
            } else if (word === "ACTIONS_END") {
                currentSection = null;
            } else if (currentSection) {
                // Append word to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "\n[Report generation complete]";
            eventSource.close();
        };
    }
});

style.css:

@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}

- This code works perfectly fine. Now i need a modifications that is after generate everything i want these to be made as a word doc and downloaded. Can you do it? 




Glad to hear the code is working perfectly now! To add the functionality of generating a Word document (.docx) with the "Summary," "Threat Patterns," and "Recommended Actions" sections and triggering a download after the report is generated, we’ll need to:

Use the python-docx library to create a Word document in the backend.
Modify app.py to generate the document and serve it as a downloadable file.
Update the frontend to trigger the download after the report streaming completes.
Here’s how we’ll do it:

Step 1: Install python-docx
Run this command in your terminal to install the library:

text

Collapse

Wrap

Copy
pip install python-docx
Updated app.py
Add Word document generation and a new route for downloading it.

python

Collapse

Wrap

Copy
import os
import pandas as pd
import google.generativeai as genai
from flask import Flask, render_template, request, redirect, url_for, jsonify, Response, send_file
import time
import re
from docx import Document
from io import BytesIO

# Configure Gemini API
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-flash")

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# **Step 1: Load and Preprocess Data**
def load_and_preprocess_data(file_path):
    """Loads the CSV file and preprocesses it."""
    try:
        df = pd.read_csv(file_path)
        df["Timestamp"] = pd.to_datetime(df["Timestamp"], errors="coerce")
        df.drop_duplicates(inplace=True)
        df.dropna(inplace=True)
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# **Step 2: Perform Threat Analysis**
def analyze_threats(df):
    """Analyzes the threat logs for high-risk events."""
    if df is None or isinstance(df, str):
        return None, None
    event_counts = df["Source IP"].value_counts().head(5).to_dict()
    high_risk_events = df[df["Severity"].isin(["High", "Critical"])]
    return event_counts, high_risk_events.to_dict(orient="records")

# **Step 3: Generate LLM-Based Cybersecurity Report**
def generate_threat_report(df):
    """Sends structured logs to Gemini LLM for reasoning and decision-making."""
    if df is None or isinstance(df, str):
        return "Error: No valid data to analyze."
    log_text = df.head(5).to_string(index=False)
    prompt = f"""
    Given the following cybersecurity logs, analyze potential threats and suggest security actions.

    Logs:
    {log_text}

    Instructions:
    1. Summarize key threats in simple terms.
    2. Identify patterns (brute-force attacks, malware, port scans, etc.).
    3. Recommend security actions (e.g., block IP, notify security team, increase firewall rules).

    Respond with fields clearly labeled as:
    "**Summary:** <your summary>"
    "**Threat Patterns:** <your patterns>"
    "**Recommended Actions:** <your actions>"
    """
    try:
        response = model.generate_content(prompt)
        print(f"Raw Gemini response:\n{repr(response.text)}")
        return response.text
    except Exception as e:
        print(f"Error generating report: {e}")
        return "Error: Failed to generate report."

# Generate Word document
def create_word_doc(summary, patterns, actions):
    """Creates a Word document with the report sections."""
    doc = Document()
    doc.add_heading("AI-Generated Cyber Threat Report", 0)

    doc.add_heading("Summary", level=1)
    doc.add_paragraph(summary)

    doc.add_heading("Threat Patterns", level=1)
    doc.add_paragraph(patterns)

    doc.add_heading("Recommended Actions", level=1)
    doc.add_paragraph(actions)

    # Save to a BytesIO object for in-memory handling
    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer

# Stream the report with sections separated by delimiters and store for Word doc
def stream_threat_report(df):
    """Streams the threat report word-by-word with section delimiters and prepares Word doc."""
    report = generate_threat_report(df)
    if not report or "Error" in report:
        yield "data: Error generating report.\n\n"
        return

    # Parse the plain text response with Markdown headers
    summary = "No summary provided."
    patterns = "No patterns identified."
    actions = "No actions recommended."

    lines = report.splitlines()
    current_section = None
    for line in lines:
        line = line.strip()
        if re.match(r"\*\*Summary:\*\*.*", line, re.IGNORECASE):
            current_section = "summary"
            summary = line[len("**Summary:**"):].strip()
        elif re.match(r"\*\*Threat Patterns:\*\*.*", line, re.IGNORECASE):
            current_section = "patterns"
            patterns = line[len("**Threat Patterns:**"):].strip()
        elif re.match(r"\*\*Recommended Actions:\*\*.*", line, re.IGNORECASE):
            current_section = "actions"
            actions = line[len("**Recommended Actions:**"):].strip()
        elif current_section and line:
            if current_section == "summary":
                summary += " " + line
            elif current_section == "patterns":
                patterns += " " + line
            elif current_section == "actions":
                actions += " " + line

    if summary == "No summary provided." and patterns == "No patterns identified." and actions == "No actions recommended.":
        print("Warning: No content parsed from Gemini response.")

    # Structure the report with delimiters
    structured_report = (
        "SUMMARY_START " + summary + " SUMMARY_END " +
        "PATTERNS_START " + patterns + " PATTERNS_END " +
        "ACTIONS_START " + actions + " ACTIONS_END"
    )
    print(f"Structured report: {structured_report}")

    # Store the parsed sections in a global variable or session for download
    global report_data
    report_data = {"summary": summary, "patterns": patterns, "actions": actions}

    # Stream word-by-word
    words = structured_report.split()
    for word in words:
        yield f"data: {word}\n\n"
        time.sleep(0.1)

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if file:
            file_path = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
            file.save(file_path)
            df = load_and_preprocess_data(file_path)
            event_counts, high_risk_events = analyze_threats(df)
            return render_template("index.html", 
                                   event_counts=event_counts,
                                   high_risk_events=high_risk_events,
                                   filename=file.filename)
    return render_template("index.html")

@app.route("/stream-report")
def stream_report():
    filename = request.args.get("filename")
    if not filename:
        return Response("data: No filename provided.\n\n", mimetype="text/event-stream")
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    df = load_and_preprocess_data(file_path)
    return Response(stream_threat_report(df), mimetype="text/event-stream")

@app.route("/download-report")
def download_report():
    """Serves the generated report as a Word document."""
    global report_data
    if not report_data:
        return "No report available for download.", 404

    buffer = create_word_doc(report_data["summary"], report_data["patterns"], report_data["actions"])
    return send_file(
        buffer,
        as_attachment=True,
        download_name="Cyber_Threat_Report.docx",
        mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    )

if __name__ == "__main__":
    report_data = None  # Global variable to store report data
    app.run(debug=True)
Updated index.html
Add a download button that appears after the report is generated.

html

Preview

Collapse

Wrap

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Threat Reasoning</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>🛡 AI-Powered Cyber Threat Reasoning</h1>
        <form method="POST" enctype="multipart/form-data" id="upload-form">
            <input type="file" name="file" required>
            <button type="submit">Analyze Threats</button>
        </form>

        {% if event_counts %}
        <div class="output">
            <h2>🔹 Top Threat Sources:</h2>
            <pre>{{ event_counts }}</pre>

            <h2>🔹 High-Risk Events:</h2>
            <pre>{{ high_risk_events }}</pre>

            <h2>🔹 AI-Generated Cyber Threat Report:</h2>
            <div id="threat-report" class="report-output">
                <div id="summary" class="report-section"><strong>Summary:</strong></div>
                <div id="patterns" class="report-section"><strong>Threat Patterns:</strong></div>
                <div id="actions" class="report-section"><strong>Recommended Actions:</strong></div>
            </div>
            <button id="download-btn" style="display: none;" onclick="window.location.href='/download-report'">Download Report as Word Doc</button>
            <script>
                // Pass filename to JavaScript
                const filename = "{{ filename }}";
            </script>
        </div>
        {% endif %}
    </div>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
Updated script.js
Show the download button when the stream ends.

javascript

Collapse

Wrap

Copy
document.addEventListener("DOMContentLoaded", function() {
    let commandInput = document.getElementById("command");
    let outputDiv = document.getElementById("output");

    if (commandInput) {
        commandInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = commandInput.value.trim();
                if (command) {
                    outputDiv.innerHTML += `<p>> ${command}</p>`;
                    processCommand(command);
                }
                commandInput.value = "";
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        });
    }

    function processCommand(command) {
        let response = "";
        if (command.toLowerCase() === "status") {
            response = "System Operational. Threat Level: LOW.";
        } else if (command.toLowerCase() === "scan") {
            response = "Scanning network for anomalies...";
        } else if (command.toLowerCase() === "exit") {
            response = "Terminating session...";
        } else {
            response = "Unknown command.";
        }
        outputDiv.innerHTML += `<p>${response}</p>`;
    }

    // Stream the threat report if filename is available
    const reportDiv = document.getElementById("threat-report");
    const downloadBtn = document.getElementById("download-btn");
    if (reportDiv && typeof filename !== "undefined" && filename) {
        console.log("Streaming report for filename:", filename);
        const eventSource = new EventSource(`/stream-report?filename=${encodeURIComponent(filename)}`);
        
        let currentSection = null;
        const summaryDiv = document.getElementById("summary");
        const patternsDiv = document.getElementById("patterns");
        const actionsDiv = document.getElementById("actions");

        eventSource.onmessage = function(event) {
            const word = event.data.trim();
            console.log("Received data:", word);

            // Switch sections based on delimiters
            if (word === "SUMMARY_START") {
                currentSection = "summary";
            } else if (word === "SUMMARY_END") {
                currentSection = null;
            } else if (word === "PATTERNS_START") {
                currentSection = "patterns";
            } else if (word === "PATTERNS_END") {
                currentSection = null;
            } else if (word === "ACTIONS_START") {
                currentSection = "actions";
            } else if (word === "ACTIONS_END") {
                currentSection = null;
            } else if (currentSection) {
                // Append word to the current section
                if (currentSection === "summary") {
                    summaryDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "patterns") {
                    patternsDiv.innerHTML += ` ${word}`;
                } else if (currentSection === "actions") {
                    actionsDiv.innerHTML += ` ${word}`;
                }
            }

            reportDiv.scrollTop = reportDiv.scrollHeight; // Auto-scroll
        };

        eventSource.onerror = function() {
            console.log("Stream ended or error occurred");
            reportDiv.innerHTML += "\n[Report generation complete]";
            downloadBtn.style.display = "block"; // Show download button
            eventSource.close();
        };
    }
});
Updated style.css
Style the download button.

css

Collapse

Wrap

Copy
@import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

body {
    background-color: #0d1117;
    color: #00ff00;
    font-family: 'Orbitron', sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
}

.container {
    width: 60%;
    margin: auto;
    padding: 20px;
    border: 2px solid #00ff00;
    background-color: #000;
    box-shadow: 0px 0px 10px #00ff00;
}

h1, h2 {
    color: #00ff00;
    text-shadow: 0px 0px 5px #00ff00;
}

button {
    background-color: black;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: #00ff00;
    color: black;
}

pre {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    overflow-x: auto;
}

.report-output {
    text-align: left;
    background: #111;
    padding: 10px;
    border: 1px solid #00ff00;
    min-height: 100px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.report-section {
    margin-bottom: 10px;
}

.report-section strong {
    color: #00cc00; /* Slightly darker green for emphasis */
}

#download-btn {
    margin-top: 10px;
}
How It Works
Backend (app.py):
Added create_word_doc to generate a .docx file using python-docx.
Stored the parsed summary, patterns, and actions in a global report_data variable during stream_threat_report.
Added a /download-report route that creates and serves the Word document as a downloadable file.
Frontend (index.html and script.js):
Added a "Download Report as Word Doc" button, initially hidden.
Updated script.js to show the button when the stream ends (onerror event) by setting downloadBtn.style.display = "block".
The button links to /download-report, triggering the download.
Styling (style.css):
Styled the download button to match the theme and added a margin for spacing.
Expected Behavior
Upload Cyber_logs.csv.
The report streams word-by-word into the "Summary," "Threat Patterns," and "Recommended Actions" <div>s.
After [Report generation complete] appears, the "Download Report as Word Doc" button becomes visible.
Click the button, and a file named Cyber_Threat_Report.docx downloads with the report content:
Heading: "AI-Generated Cyber Threat Report"
Subheading: "Summary" with its content
Subheading: "Threat Patterns" with its content
Subheading: "Recommended Actions" with its content
Notes
Global Variable: Using report_data as a global variable is a simple solution for this demo. For a production app, consider using Flask’s session or a more robust storage mechanism to handle multiple users.
File Name: The downloaded file is named Cyber_Threat_Report.docx. You can customize this in the download_name parameter if needed.
Try it out and let me know if it works as expected or if you need any tweaks!






wow it works perfectly fine thank you so much


You’re very welcome! I’m thrilled to hear it’s working perfectly for you. If you need any more features, tweaks, or have other projects in mind, feel free to reach out—I’d be happy to help. Enjoy your AI-powered cyber threat reporting tool!







How can Grok help?


DeepSearch


Think

Grok 3

